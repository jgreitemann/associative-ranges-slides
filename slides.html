<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal-md</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/night.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/github-dark-dimmed.css" />

    <link rel="stylesheet" href="./_assets/style.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template"><!-- .slide: data-background-image="lightning.jpg" data-background-opacity="0.4" -->
## `ranges::operator|` is&nbsp;associative
<!-- .element: class="shadow" -->

<br/>
<br/>

### Jonas Greitemann
<!-- .element: class="shadow" -->
https://greitemann.dev
<!-- .element: class="shadow" -->
</script></section><section  data-markdown><script type="text/template">
### ⚠️ Disclaimer

* This is an addendum to Tina Ulbrich's talk
* If you haven't seen her talk, go [watch it][cpponsea-talk]
* C++23 `std::ranges` assumed
* I didn't `constexpr` all the things
* No perfect forwarding

[cpponsea-talk]: https://www.youtube.com/watch?v=Ln_cVjJl680

<aside class="notes"><ul>
<li>MSVC has support for everything I&#39;ll show</li>
<li>Godbolt links at the end</li>
<li>Slideware</li>
</ul>
</aside></script></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->
#### Tina's `sliding_mean` example

```cpp[]
auto sliding_mean(std::span<double const> rng)
    -> std::vector<double>
{
  auto out = std::vector<double>(rng.size() - 4);
  for (size_t i = 2; i < rng.size() - 2; ++i) {
      out[i - 2] = mean(std::array{
        rng[i-2], rng[i-1], rng[i], rng[i+1], rng[i+2]
      });
  }
  return out;
}
```
<!-- .element: data-id="tinas-example" -->
</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->
#### Tina's `sliding_mean` example

```cpp [|2,6]
auto sliding_mean(std::span<double const> rng)
    -> std::vector<double>
{
  return rng | std::views::slide(5)
             | std::views::transform(mean)
             | std::ranges::to<std::vector>();
}
```
<!-- .element: data-id="tinas-example" -->

```cpp
std::array a = {3., 1., 4., 1., 5., 9., 2., 6., 5., 3.};
fmt::print("{}\n", sliding_mean(a)
                   | std::views::transform(round_to_int));
```
<!-- .element: class="fragment" -->

<aside class="notes"><ul>
<li>Tina used range-v3&#39;s <code>sliding</code> view</li>
<li><strong>Step</strong>: Drop-in replacement</li>
<li><strong>Step</strong>: {fmt} library</li>
<li>Eager</li>
</ul>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
#### Eager evaluation
<!-- .element: data-id="gif-heading" -->

<!-- .slide: data-auto-animate data-auto-animate-restart -->
<iframe data-src="https://giphy.com/embed/ATXUOl4iE5ZPq" width="383" height="480" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
</script></section><section data-markdown><script type="text/template">
#### Lazy evaluation
<!-- .element: data-id="gif-heading" -->

<!-- .slide: data-auto-animate -->
<iframe data-src="https://giphy.com/embed/WoCxkkpiweO6Q" width="480" height="284" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate data-auto-animate-restart -->
#### Returning lazy views instead
```cpp [|2]
auto sliding_mean(std::span<double const> rng)
    -> std::ranges::random_access_range auto
{
  return rng | std::views::slide(5)
             | std::views::transform(mean);
}
```
<!-- .element: data-id="gen-out" -->

```cpp
std::array a = {3., 1., 4., 1., 5., 9., 2., 6., 5., 3.};
fmt::print("{}\n", sliding_mean(a)
                   | std::views::transform(round_to_int));
```

<aside class="notes"><ul>
<li><code>ranges::to</code> dropped</li>
<li><strong>Step</strong>: Returns lazy view; constrained</li>
<li>work happens in <code>fmt::print</code></li>
<li>no heap allocation</li>
</ul>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->
#### Can we be even more lazy?
```cpp []
auto sliding_mean(std::span<double const> rng)
    -> std::ranges::random_access_range auto
{
  return rng | std::views::slide(5)
             | std::views::transform(mean);
}
```
<!-- .element: class="mark error squiggle-params" data-id="gen-out" -->

```cpp
fmt::print("{}\n", sliding_mean(std::views::iota(0, 30)
                                | std::views::filter(is_even))
                   | std::views::transform(round_to_int));
```
<!-- .element: class="mark question" -->

<aside class="notes"><ul>
<li>So far: <code>span</code> (contiguous + sized)</li>
<li>Doesn&#39;t work with e.g. <code>forward_range</code>s</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->
#### Accepting ranges as function arguments
```cpp [1,2|1,2,5]
auto sliding_mean(std::ranges::forward_range auto rng)
    -> std::ranges::forward_range auto
{
  return rng | std::views::slide(5)
             | std::views::transform(mean);
}
```
<!-- .element: class="mark error squiggle-mean" data-id="gen-out" -->

```cpp
fmt::print("{}\n", sliding_mean(std::views::iota(0, 30)
                                | std::views::filter(is_even))
                   | std::views::transform(round_to_int));
```

<aside class="notes"><ul>
<li>Becomes a function template</li>
<li><code>slide</code> requires at least a <code>forward_range</code></li>
<li><strong>Step</strong>: Doesn&#39;t compile with <code>mean</code> as-is</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate data-auto-animate-restart -->
#### Generalizing `mean` to work with ranges
```cpp
constexpr auto mean(std::span<double const> rng) -> double {
  return std::reduce(rng.begin(), rng.end(), 0.) / rng.size();
}
```
<!-- .element: class="mark error squiggle-params" data-id="mean" -->

<aside class="notes"><ul>
<li>Also accepts <code>span</code></li>
<li>Worked before b/c <code>slide</code> preserves contiguity</li>
<li>Needs to be generalized, too</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->
#### Generalizing `mean` to work with ranges
```cpp
constexpr auto mean(std::ranges::sized_range auto rng)
    -> double
{
  using std::ranges::begin;
  using std::ranges::end;
  using std::ranges::size;
  return std::reduce(begin(rng), end(rng), 0.) / size(rng);
}
```
<!-- .element: class="mark error squiggle-return" data-id="mean" -->

<aside class="notes"><ul>
<li>Also becomes a function template</li>
<li><code>slide</code> yields <code>sized_range</code>s</li>
<li>Problem:<ul>
<li><code>&lt;numeric&gt;</code> algorithms not yet rangified</li>
<li>Ranges iterators can have sentinels</li>
</ul>
</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->
#### Generalizing `mean` to work with ranges
```cpp
constexpr auto mean(std::ranges::sized_range auto rng)
    -> double
{
  using std::ranges::begin;
  using std::ranges::end;
  using std::ranges::size;
  auto c = rng | std::views::common;
  return std::reduce(begin(c), end(c), 0.) / size(rng);
}
```
<!-- .element: class="mark no-error" data-id="mean" -->

```cpp
   ... | std::views::transform(mean)
```
<!-- .element: class="fragment mark error" -->

<aside class="notes"><ul>
<li><code>common_view</code> works around this problem</li>
<li>This version compiles perfectly well</li>
<li><strong>Step</strong>: But template cannot be used a function ref</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->
#### Generalizing `mean` to work with ranges
```cpp
inline constexpr auto mean =
    [](std::ranges::sized_range auto rng) -> double {
      using std::ranges::begin;
      using std::ranges::end;
      using std::ranges::size;
      auto c = rng | std::views::common;
      return std::reduce(begin(c), end(c), 0.) / size(rng);
    };
```
<!-- .element: class="mark no-error" data-id="mean-functor" -->

```cpp
   ... | std::views::transform(mean)
```
<!-- .element: class="mark no-error" -->

<aside class="notes"><ul>
<li>Turn <code>mean</code> into a function object (e.g. lambda)</li>
<li><code>mean</code> itself is not a template</li>
<li>Call operator is generic</li>
</ul>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate data-auto-animate-restart -->
#### Functionally complete, but ugly...
```cpp
fmt::print("{}\n", sliding_mean(std::views::iota(0, 30)
                                | std::views::filter(is_even))
                   | std::views::transform(round_to_int));
```
<!-- .element: class="mark no-error" data-id="pipe-usage" -->

<aside class="notes"><ul>
<li>Functionally where we want to be (lazy)</li>
<li>Awkward to write</li>
<li>Potentially confusing (eager → lazy)</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->
#### Can we use pipeline syntax for user-defined range adaptors?
```cpp
fmt::print("{}\n", std::views::iota(0, 30)
                   | std::views::filter(is_even))
                   | sliding_mean
                   | std::views::transform(round_to_int));
```
<!-- .element: class="mark question" data-id="pipe-usage" -->

<aside class="notes"><ul>
<li>Difficult to enable in C++20 w/o injecting in <code>std::ranges</code></li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->
#### [P2387: Pipe support for user-defined range adaptors][p2387]
```cpp
struct sliding_mean_fn
  : std::ranges::range_adaptor_closure<sliding_mean_fn>
{
  constexpr auto operator()(forward_range auto&& rng) const
      -> std::ranges::forward_range auto
  {
    return rng | std::views::slide(5)
               | std::views::transform(mean);
  }
};

inline constexpr sliding_mean_fn sliding_mean;
```

```cpp
fmt::print("{}\n", std::views::iota(0, 30)
                   | std::views::filter(is_even))
                   | sliding_mean
                   | std::views::transform(round_to_int));
```
<!-- .element: class="mark no-error" data-id="pipe-usage" -->

[p2387]: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2387r3.html

<aside class="notes"><ul>
<li>Paper by Barry Revzin; accepted for C++23</li>
<li>CRTP base class <code>range_adaptor_closure</code></li>
<li>Our function becomes its call operator</li>
<li>Customization point; not too much boilerplate</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate data-auto-animate-restart -->
#### `std::ranges::operator|` is associative

<aside class="notes"><ul>
<li>There&#39;s a much simpler way for composite adaptors</li>
<li>Circle back to title</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->
#### `std::ranges::operator|` is associative

```cpp
(rng | slide(5)) | transform(mean)
```
<!-- .element: class="code-centered" -->

⇕

```cpp
rng | (slide(5) | transform(mean))
```
<!-- .element: class="code-centered" -->
</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->
#### `std::ranges::operator|` is associative

```cpp
inline constexpr auto sliding_mean =
    std::views::slide(5) | std::views::transform(mean);
```

```cpp
fmt::print("{}\n", std::views::iota(0, 30)
                   | std::views::filter(is_even))
                   | sliding_mean
                   | std::views::transform(round_to_int));
```
<!-- .element: class="mark no-error" data-id="pipe-usage" -->

<aside class="notes"><ul>
<li>Specify function object directly by composition</li>
<li>&quot;Point-free&quot; programming</li>
<li>Constraints of <code>slide</code> automatically carry over</li>
<li>Works in C++20 w/o support for P2387</li>
</ul>
</aside></script></section></section><section  data-markdown><script type="text/template">
![qr.svg](qr.svg)
<!-- .element: class="qr" -->

### That's it

* Blog post, Godbolt links & slides: [https://greitemann.dev/pipe-assoc][1]
* Questions?

[1]: https://greitemann.dev/pipe-assoc

<aside class="notes"><ul>
<li>Questions?</li>
<li>Enjoy the main talk</li>
</ul>
</aside></script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"slideNumber":true,"transition":"slide"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
